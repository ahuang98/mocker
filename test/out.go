// Code generated by mocker; DO NOT EDIT
// github.com/travisjeffery/mocker
package test

import (
	"sync"
)

var (
	lockIfaceMockOne sync.RWMutex
	lockIfaceMockTwo sync.RWMutex
)

// IfaceMock is a mock implementation of Iface.
//
//     func TestSomethingThatUsesIface(t *testing.T) {
//
//         // make and configure a mocked Iface
//         mockedIface := &IfaceMock{
//             OneFunc: func(str string,variadic ...string) (string, []string) {
// 	               panic("TODO: mock out the One method")
//             },
//             TwoFunc: func(in1 int,in2 int) int {
// 	               panic("TODO: mock out the Two method")
//             },
//         }
//
//         // TODO: use mockedIface in code that requires Iface
//         //       and then make assertions.
//
//     }
type IfaceMock struct {
	// OneFunc mocks the One method.
	OneFunc func(str string, variadic ...string) (string, []string)

	// TwoFunc mocks the Two method.
	TwoFunc func(in1 int, in2 int) int

	// calls tracks calls to the methods.
	calls struct {
		// One holds details about calls to the One method.
		One []struct {
			// Str is the str argument value.
			Str string
			// Variadic is the variadic argument value.
			Variadic []string
		}
		// Two holds details about calls to the Two method.
		Two []struct {
			// In1 is the in1 argument value.
			In1 int
			// In2 is the in2 argument value.
			In2 int
		}
	}
}

// Reset resets the calls made to the mocked APIs.
func (mock *IfaceMock) Reset() {
	lockIfaceMockOne.Lock()
	mock.calls.One = nil
	lockIfaceMockOne.Unlock()
	lockIfaceMockTwo.Lock()
	mock.calls.Two = nil
	lockIfaceMockTwo.Unlock()
}

// One calls OneFunc.
func (mock *IfaceMock) One(str string, variadic ...string) (string, []string) {
	if mock.OneFunc == nil {
		panic("moq: IfaceMock.OneFunc is nil but Iface.One was just called")
	}
	callInfo := struct {
		Str      string
		Variadic []string
	}{
		Str:      str,
		Variadic: variadic,
	}
	lockIfaceMockOne.Lock()
	mock.calls.One = append(mock.calls.One, callInfo)
	lockIfaceMockOne.Unlock()
	return mock.OneFunc(str, variadic...)
}

// OneCalled returns true if at least one call was made to One.
func (mock *IfaceMock) OneCalled() bool {
	lockIfaceMockOne.RLock()
	defer lockIfaceMockOne.RUnlock()
	return len(mock.calls.One) > 0
}

// OneCalls gets all the calls that were made to One.
// Check the length with:
//     len(mockedIface.OneCalls())
func (mock *IfaceMock) OneCalls() []struct {
	Str      string
	Variadic []string
} {
	var calls []struct {
		Str      string
		Variadic []string
	}
	lockIfaceMockOne.RLock()
	calls = mock.calls.One
	lockIfaceMockOne.RUnlock()
	return calls
}

// Two calls TwoFunc.
func (mock *IfaceMock) Two(in1 int, in2 int) int {
	if mock.TwoFunc == nil {
		panic("moq: IfaceMock.TwoFunc is nil but Iface.Two was just called")
	}
	callInfo := struct {
		In1 int
		In2 int
	}{
		In1: in1,
		In2: in2,
	}
	lockIfaceMockTwo.Lock()
	mock.calls.Two = append(mock.calls.Two, callInfo)
	lockIfaceMockTwo.Unlock()
	return mock.TwoFunc(in1, in2)
}

// TwoCalled returns true if at least one call was made to Two.
func (mock *IfaceMock) TwoCalled() bool {
	lockIfaceMockTwo.RLock()
	defer lockIfaceMockTwo.RUnlock()
	return len(mock.calls.Two) > 0
}

// TwoCalls gets all the calls that were made to Two.
// Check the length with:
//     len(mockedIface.TwoCalls())
func (mock *IfaceMock) TwoCalls() []struct {
	In1 int
	In2 int
} {
	var calls []struct {
		In1 int
		In2 int
	}
	lockIfaceMockTwo.RLock()
	calls = mock.calls.Two
	lockIfaceMockTwo.RUnlock()
	return calls
}
