package mocker

import (
	"strings"
	"text/template"
)

var tmplFns = template.FuncMap{
	"Export": func(s string) string {
		if s == "" {
			return ""
		}
		return strings.ToUpper(s[0:1]) + s[1:]
	},
}

var tmpl = `// Code generated by mocker; DO NOT EDIT
// github.com/travisjeffery/mocker
package {{.Pkg}}
import (
{{- range .Imports }}
	{{.Name}} "{{.Path}}"
{{- end }}
)
{{ range $i, $iface := .Ifaces -}}
var (
{{- range .Methods }}
	lock{{$iface.Prefix}}{{$iface.Name}}{{$iface.Suffix}}{{.Name}}	sync.RWMutex
{{- end }}
)
// {{.Prefix}}{{.Name}}{{.Suffix}} is a mock implementation of {{.Name}}.
//
//     func TestSomethingThatUses{{.Name}}(t *testing.T) {
//
//         // make and configure a mocked {{.Name}}
//         mocked{{.Name}} := &{{.Prefix}}{{.Name}}{{.Suffix}}{ {{ range .Methods }}
//             {{.Name}}Func: func({{ .ParamStr }}) {{.ReturnStr}} {
// 	               panic("TODO: mock out the {{.Name}} method")
//             },{{- end }}
//         }
//
//         // TODO: use mocked{{.Name}} in code that requires {{.Name}}
//         //       and then make assertions.
//
//     }
type {{.Prefix}}{{.Name}}{{.Suffix}} struct {
{{- range .Methods }}
	// {{.Name}}Func mocks the {{.Name}} method.
	{{.Name}}Func func({{ .ParamStr }}) {{.ReturnStr}}
{{ end }}
	// calls tracks calls to the methods.
	calls struct {
{{- range .Methods }}
		// {{ .Name }} holds details about calls to the {{.Name}} method.
		{{ .Name }} []struct {
			{{- range .Params }}
			// {{ .Name | Export }} is the {{ .Name }} argument value.
			{{ .Name | Export }} {{ .Type }}
			{{- end }}
		}
{{- end }}
	}
}
// Reset resets the calls made to the mocked APIs.
func (mock *{{$iface.Prefix}}{{$iface.Name}}{{$iface.Suffix}}) Reset() {
{{- range .Methods }}
	lock{{$iface.Prefix}}{{$iface.Name}}{{$iface.Suffix}}{{.Name}}.Lock()
	mock.calls.{{.Name}} = nil
	lock{{$iface.Prefix}}{{$iface.Name}}{{$iface.Suffix}}{{.Name}}.Unlock()
{{- end }}
}
{{ range .Methods }}
// {{.Name}} calls {{.Name}}Func.
func (mock *{{$iface.Prefix}}{{$iface.Name}}{{$iface.Suffix}}) {{.Name}}({{.ParamStr}}) {{.ReturnStr}} {
	if mock.{{.Name}}Func == nil {
		panic("mocker: {{$iface.Prefix}}{{$iface.Name}}{{$iface.Suffix}}.{{.Name}}Func is nil but {{$iface.Name}}.{{.Name}} was just called")
	}
	callInfo := struct {
		{{- range .Params }}
		{{ .Name | Export }} {{ .Type }}
		{{- end }}
	}{
		{{- range .Params }}
		{{ .Name | Export }}: {{ .Name }},
		{{- end }}
	}
	lock{{$iface.Prefix}}{{$iface.Name}}{{$iface.Suffix}}{{.Name}}.Lock()
	mock.calls.{{.Name}} = append(mock.calls.{{.Name}}, callInfo)
	lock{{$iface.Prefix}}{{$iface.Name}}{{$iface.Suffix}}{{.Name}}.Unlock()
{{- if .ReturnStr }}
	return mock.{{.Name}}Func({{.CallStr}})
{{- else }}
	mock.{{.Name}}Func({{.CallStr}})
{{- end }}
}

// {{.Name}}Called returns true if at least one call was made to {{.Name}}.
func (mock *{{$iface.Prefix}}{{$iface.Name}}{{$iface.Suffix}}) {{.Name}}Called() bool {
	lock{{$iface.Prefix}}{{$iface.Name}}{{$iface.Suffix}}{{.Name}}.RLock()
	defer lock{{$iface.Prefix}}{{$iface.Name}}{{$iface.Suffix}}{{.Name}}.RUnlock()
	return len(mock.calls.{{.Name}}) > 0
}
// {{.Name}}Calls gets all the calls that were made to {{.Name}}.
// Check the length with:
//     len(mocked{{$iface.Name}}.{{.Name}}Calls())
func (mock *{{$iface.Prefix}}{{$iface.Name}}{{$iface.Suffix}}) {{.Name}}Calls() []struct {
		{{- range .Params }}
		{{ .Name | Export }} {{ .Type }}
		{{- end }}
	} {
	var calls []struct {
		{{- range .Params }}
		{{ .Name | Export }} {{ .Type }}
		{{- end }}
	}
	lock{{$iface.Prefix}}{{$iface.Name}}{{$iface.Suffix}}{{.Name}}.RLock()
	calls = mock.calls.{{.Name}}
	lock{{$iface.Prefix}}{{$iface.Name}}{{$iface.Suffix}}{{.Name}}.RUnlock()
	return calls
}
{{ end -}}
{{ end -}}`
